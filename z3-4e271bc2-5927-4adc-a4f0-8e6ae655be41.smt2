(set-option :produce-unsat-cores true)
(set-option :smt.core.minimize false)
(set-option :produce-proofs true)
(declare-sort NAryTree)
(declare-fun %c/2 () NAryTree)
(declare-fun %%c/2_x1 () NAryTree)
(declare-fun %%c/2_x2 () NAryTree)
(declare-fun %c_base/0 () NAryTree)
(declare-fun depth_with_condition (NAryTree) Int)
(declare-fun max (Int Int) Int)
(declare-fun depth_with_max (NAryTree) Int)
(declare-fun size (NAryTree) Int)
(assert (not (= %c/2 %%c/2_x1)))
(assert (not (= %c/2 %%c/2_x2)))
(assert ( ! (=> (> (depth_with_condition %%c/2_x1) (depth_with_condition %%c/2_x2)) (= (depth_with_condition %c/2) (+ 1 (depth_with_condition %%c/2_x1)))) :named definitionDepth_with_conditionNumber1Arity1InputTypesNAryTreeOutputTypeInt1))
(assert ( ! (=> (not (> (depth_with_condition %%c/2_x1) (depth_with_condition %%c/2_x2))) (= (depth_with_condition %c/2) (+ 1 (depth_with_condition %%c/2_x2)))) :named definitionDepth_with_conditionNumber1Arity1InputTypesNAryTreeOutputTypeIntOtherwise))
(assert ( ! (= (depth_with_condition %c_base/0) 1) :named definitionDepth_with_conditionNumber2Arity1InputTypesNAryTreeOutputTypeIntOtherwise))
(assert ( ! (forall ((x Int) (y Int)) (=> (> x y) (= (max x y) x))) :named definitionMaxNumber1Arity2InputTypesIntIntOutputTypeInt1))
(assert ( ! (forall ((x Int) (y Int)) (=> (not (> x y)) (= (max x y) y))) :named definitionMaxNumber1Arity2InputTypesIntIntOutputTypeIntOtherwise))
(assert ( ! (= (depth_with_max %c/2) (+ 1 (max (depth_with_max %%c/2_x1) (depth_with_max %%c/2_x2)))) :named definitionDepth_with_maxNumber1Arity1InputTypesNAryTreeOutputTypeIntOtherwise))
(assert ( ! (= (depth_with_max %c_base/0) 1) :named definitionDepth_with_maxNumber2Arity1InputTypesNAryTreeOutputTypeIntOtherwise))
(assert ( ! (= (size %c/2) (+ 1 (+ (size %%c/2_x1) (size %%c/2_x2)))) :named definitionSizeNumber1Arity1InputTypesNAryTreeOutputTypeIntOtherwise))
(assert ( ! (= (size %c_base/0) 1) :named definitionSizeNumber2Arity1InputTypesNAryTreeOutputTypeIntOtherwise))
(check-sat)
(assert ( ! (and (<= (depth_with_condition %%c/2_x1) (size %%c/2_x1)) (= (depth_with_max %%c/2_x1) (depth_with_condition %%c/2_x1))) :named inductionAssumption0))
(assert ( ! (and (<= (depth_with_condition %%c/2_x2) (size %%c/2_x2)) (= (depth_with_max %%c/2_x2) (depth_with_condition %%c/2_x2))) :named inductionAssumption1))
(check-sat)
(assert ( ! (forall ((t NAryTree)) (< 0 (size t))) :named additionalConstraint0))
(check-sat)
(assert ( ! (and (<= (depth_with_condition %c_base/0) (size %c_base/0)) (= (depth_with_max %c_base/0) (depth_with_condition %c_base/0))) :named inductiveBasis))
(check-sat)
(assert ( ! (not (and (<= (depth_with_condition %c/2) (size %c/2)) (= (depth_with_max %c/2) (depth_with_condition %c/2)))) :named statementToProve))
(check-sat)
(get-unsat-core)
(get-proof)
(exit)